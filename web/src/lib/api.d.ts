/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
	"/healthz": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** Liveness probe */
		get: operations["healthz"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/readyz": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** Readiness probe */
		get: operations["readyz"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/tasks": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** List agent tasks */
		get: operations["listTasks"];
		put?: never;
		/** Create a new agent task */
		post: operations["createTask"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/tasks/{taskID}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** Get a single task */
		get: operations["getTask"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/tasks/{taskID}/events": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Stream task events via WebSocket
		 * @description Upgrades to a WebSocket connection for real-time event streaming.
		 *     The server sends JSON messages of type WSMessage with "task_event"
		 *     or "task_complete" types. Use the ?after query parameter to resume
		 *     from a specific sequence number after reconnection.
		 */
		get: operations["streamEvents"];
		put?: never;
		/** Post agent events for a task (runner â†’ API) */
		post: operations["postEvents"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/tasks/{taskID}/status": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/** Update task status (runner callback) */
		post: operations["updateTaskStatus"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/tasks/{taskID}/data": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** Get task data for runner */
		get: operations["getTaskData"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/v1/tasks/{taskID}/token": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** Get GitHub installation token scoped to task repo */
		get: operations["getTaskToken"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
}
export type webhooks = Record<string, never>;
export interface components {
	schemas: {
		CreateTaskRequest: {
			repo: components["schemas"]["RepoRequest"];
			task: components["schemas"]["TaskRequest"];
			/** Format: uri */
			callbackURL: string;
			runner: components["schemas"]["RunnerConfig"];
			labels?: {
				[key: string]: string;
			};
		};
		RepoRequest: {
			/** Format: uri */
			url: string;
			ref?: string;
		};
		TaskRequest: {
			description: string;
			context?: string;
			sourceURL?: string;
			sourceType?: string;
			sourceID?: string;
		};
		RunnerConfig: {
			sandboxTemplateName: string;
			timeout?: string;
			serviceAccountName?: string;
		};
		TaskResponse: {
			id: string;
			namespace: string;
			repo: components["schemas"]["RepoRequest"];
			task: components["schemas"]["TaskRequest"];
			callbackURL: string;
			status: components["schemas"]["TaskStatusSummary"];
			/** Format: date-time */
			createdAt: string;
			/** Format: date-time */
			completionTime?: string | null;
		};
		TaskStatusSummary: {
			phase: string;
			message: string;
			sandboxClaimName?: string;
			prURL?: string;
			error?: string;
		};
		StatusUpdateRequest: {
			/** @enum {string} */
			event: "started" | "progress" | "completed" | "failed";
			message?: string;
			details?: {
				[key: string]: unknown;
			};
		};
		StatusAcceptedResponse: {
			status: string;
			note?: string;
		};
		TaskDataResponse: {
			description: string;
			context: string;
			sourceURL?: string;
			repo: components["schemas"]["RepoRequest"];
		};
		TokenResponse: {
			token: string;
			/** Format: date-time */
			expiresAt: string;
		};
		PostEventRequest: {
			events: components["schemas"]["TaskEvent"][];
		};
		TaskEvent: {
			/** Format: int64 */
			sequence: number;
			/** Format: date-time */
			timestamp: string;
			/** @enum {string} */
			type: "thinking" | "tool_call" | "tool_result" | "error";
			summary: string;
			tool?: string;
			input?: {
				[key: string]: unknown;
			};
			output?: components["schemas"]["TaskEventOutput"];
			metadata?: {
				[key: string]: unknown;
			};
		};
		TaskEventOutput: {
			success: boolean;
			summary?: string;
		};
		ErrorResponse: {
			error: string;
			details?: string;
		};
	};
	responses: never;
	parameters: {
		taskID: string;
	};
	requestBodies: never;
	headers: never;
	pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
	healthz: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Healthy */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"text/plain": string;
				};
			};
		};
	};
	readyz: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Ready */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"text/plain": string;
				};
			};
			/** @description Not ready */
			503: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"text/plain": string;
				};
			};
		};
	};
	listTasks: {
		parameters: {
			query?: {
				/** @description Filter by shepherd.io/repo label */
				repo?: string;
				/** @description Filter by shepherd.io/issue label */
				issue?: string;
				/** @description Filter by shepherd.io/fleet label */
				fleet?: string;
				/** @description If "true", only return non-terminal tasks */
				active?: "true" | "false";
			};
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description List of tasks */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["TaskResponse"][];
				};
			};
		};
	};
	createTask: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["CreateTaskRequest"];
			};
		};
		responses: {
			/** @description Task created */
			201: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["TaskResponse"];
				};
			};
			/** @description Invalid request */
			400: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Compressed context exceeds size limit */
			413: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Content-Type must be application/json */
			415: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
		};
	};
	getTask: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				taskID: components["parameters"]["taskID"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Task details */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["TaskResponse"];
				};
			};
			/** @description Task not found */
			404: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
		};
	};
	streamEvents: {
		parameters: {
			query?: {
				/** @description Only return events with sequence > this value (for reconnection) */
				after?: number;
			};
			header?: never;
			path: {
				taskID: components["parameters"]["taskID"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description WebSocket upgrade */
			101: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
			/** @description Invalid after parameter */
			400: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Task not found */
			404: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
		};
	};
	postEvents: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				taskID: components["parameters"]["taskID"];
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["PostEventRequest"];
			};
		};
		responses: {
			/** @description Events accepted */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["StatusAcceptedResponse"];
				};
			};
			/** @description Invalid request */
			400: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Task not found */
			404: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Task is terminal */
			410: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Content-Type must be application/json */
			415: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Internal server error */
			500: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
		};
	};
	updateTaskStatus: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				taskID: components["parameters"]["taskID"];
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["StatusUpdateRequest"];
			};
		};
		responses: {
			/** @description Status accepted */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["StatusAcceptedResponse"];
				};
			};
			/** @description Invalid request */
			400: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Task not found */
			404: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Content-Type must be application/json */
			415: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Internal server error */
			500: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
		};
	};
	getTaskData: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				taskID: components["parameters"]["taskID"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Task data */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["TaskDataResponse"];
				};
			};
			/** @description Task not found */
			404: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Task is terminal */
			410: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
		};
	};
	getTaskToken: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				taskID: components["parameters"]["taskID"];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Token generated */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["TokenResponse"];
				};
			};
			/** @description Task not found */
			404: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Token already issued */
			409: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Task is terminal */
			410: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
		};
	};
}
